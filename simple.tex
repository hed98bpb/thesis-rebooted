\chapter{Simple $O(n^3 +k n^2)$ implementation}
In this section we describe an $O(n^3+k n^2)$ implementation which solves the
"Shortest Paths in Plane with Obstacles Violations"-problem. Recall that $n$ is
the number of vertices in the polygons and $k$ is the number of polygon
violations allowed. In the first section we describe how we construct the
visibility graph. Imagine a plane with a starting point $s$, an end point $t$,
and $\mathcal{O}$ polygon obstacles, which is build of groups of connected points,
each representing an obstacle. A visibility graph is a graph where for each set of
points $p,q\in \mathcal{O} \cup \{s,t\}$  there is an edge between them if the 
two points can see each other
without going (or looking) through any interior of an obstacle (see figure
\ref{visibilitygraph}). In the second section we explain Dijkstra's algorithm
for finding the shortest path from $s$ to $t$ in the visibility graph and
finally in the third section we test our implementation to compare if the actual 
running time is the same as the theoretical.

\begin{figure}[H]
	\begin{subfigure}{.5\textwidth}
		\includegraphics[width=6cm]{figures/visibilitygraph1.pdf}
		\caption{}
	\label{fig:visibilitygraph1}
	\end{subfigure}
	\begin{subfigure}{.5\textwidth}
		\includegraphics[width=6cm]{figures/visibilitygraph.pdf}
		\caption{}
		\label{fig:visibilitygraph2}
	\end{subfigure}
	\caption{Example of visibility graph}
	\label{visibilitygraph}
\end{figure}

\section{Constructing the visibility graph}
The naive way of constructing a visibility graph is to make a graph
where every set of points $p,q \in \mathcal{O} \cup \{s,t\}$ is connected to each other,
then removing all edges that crosses the interior of a polygon. But in this
setting we are allowed to cross $k$ polygons, so we construct the graph a bit
different. Given a set $\mathcal{O}$ consisting of all the polygons, where each polygon
is a list of the points in the polygon we use the following algorithm \ref{algo:MakeVisibilityGraph}.  
Create a graph $G_0=(V,E)$, where $V$ contains all the vertices in $P\cup \{s,t\}$,
and let $E$ contain all possible connections between the vertices. Make $k$
copies of the graph and name them $G_1,\dots,G_{k}$. Algorithm \ref{algo:MakeVisibilityGraph} goes as
follows: for each graph $G_i$, take each edge $e_j\in G_i$ and call
NumberOfCrosses$(e_j)$, which returns the number of polygons from $\mathcal{O}$ that the
line segment crosses, and connect the endpoint to the corresponding point in
$G_{i+l}$, i.e.\ if you take an edge in the graph, that goes through $l$
polygons, you travel $l$ graphs up. If $i+l > k$ then delete the edge. We now
have a graph that has $k$ levels where every time you go through $k$ polygons
you go $k$ levels up.

\begin{algorithm} 
	\caption{MakeVisibilityGraph($P,s,t$)}
	\begin{algorithmic}[1]
		\ForAll{$G_i=(V_i,E_i) \in G$}
		\ForAll{$e \in E_i$}
			\State $crosses = numberOfCrossings(e)$
			\If{$crosses+i<=k$}
				\State make $e$ go from $G_i$ to $G_{i+crosses}$
			\Else
				\State delete edge $e$
			\EndIf
		\EndFor
		\EndFor
	\end{algorithmic}
	\label{algo:MakeVisibilityGraph}
\end{algorithm}

The only missing part is the numberOfCrossings function, which we will define
below.

\subsection{Number of crossings}
Calculating the number of polygons a line segment crosses is no trivial task,
since there is a number of edge cases. We try to give a brief intuition of the
edge cases, and then present our algorithm.
The first five cases (a-e) in figure \ref{fig:crossings} are allowed intersections since
it is only the interior of a polygon that we can not travel. The
next five cases (f-j) are not allowed since they travel through the interior
of the polygon.

\begin{figure}
\begin{tabular}{|c|c|c|c|c|}
      \hline
		\multicolumn{5}{|c|}{No intersection} \\
		\hline
      \addheight{\includegraphics[width=20mm]{figures/crossFig1.pdf}} &
      \addheight{\includegraphics[width=20mm]{figures/crossFig2.pdf}} &
      \addheight{\includegraphics[width=20mm]{figures/crossFig3.pdf}} &
      \addheight{\includegraphics[width=20mm]{figures/crossFig4.pdf}} &
      \addheight{\includegraphics[width=20mm]{figures/crossFig5.pdf}} \\
      \small (a) &  (b) & (c) & (d) & (e) \\
      \hline
		\multicolumn{5}{|c|}{Intersection} \\
		\hline
      \addheight{\includegraphics[width=20mm]{figures/crossFig6.pdf}} &
      \addheight{\includegraphics[width=20mm]{figures/crossFig7.pdf}} &
      \addheight{\includegraphics[width=20mm]{figures/crossFig8.pdf}} &
      \addheight{\includegraphics[width=20mm]{figures/crossFig9.pdf}} &
      \addheight{\includegraphics[width=20mm]{figures/crossFig10.pdf}} \\
      \small (f) &  (g) & (h) & (i) & (j) \\
      \hline
    \end{tabular}
    \caption{A collection of 10 different cases showing what we have 
             defined as an intersection between a polygon and a linesegment}
	\label{fig:crossings}
\end{figure}

So given a polygon $p\in P$, and a line segment $l$ we want to determine
weather $l$ crosses the polygon $p$. We start by making the list of points into
a list of line segment $p'=(p_1,p_2),(p_2,p_3),\dots,(p_{i-1},p_i)$.  Then we
observe that if a line segment crosses a line segment of a polygon, it counts
as a crossing (cases f and g). The other three cases of crossing (cases h, i
and j) all have that in common that the line segment crosses four end points
from the polygon. So we say it is not allowed to cross four points in of
a polygons line segments. The problem is that it makes (cases a, c
and d) not allowed which they should be. But fortunately they all have that in
common that they are collinear with a line segment of the polygon, so the
algorithm becomes 

\begin{enumerate}
	\item if line segment crosses a line segment of a polygon it crosses the
		polygon
	\item if a line has four points  in common with the polygon it crosses the
		polygon, unless the line segment is collinear with a line segment of the
		polygon 
\end{enumerate}

This lead us to the following algorithm
\nick{Write this algorithm}
\begin{algorithm} 
	\caption{NumberOfCrossings($l,P$)}
	\begin{algorithmic}[1] 
		\State \text{TODO}
	\end{algorithmic}
\end{algorithm}

\subsection{Crosses}
To make a crosses function, we need a right turn function. Consider three
points $p_1,p_2,p_3$, we make a line going through $p_1$ and $p_2$, now if
stand at point $p_1$ and look in the direction of $p_2$ will $p_3$, if $p_3$
doesn't lie on the same line as $p_1$ and $p_2$ will it be on the
right or the left of the line. 
Let $p_i.x$ and $p_i.y$ denote the x-coordinates
and y-coordinates respectively.
To find out weather the three points are a right turn, left turn or colinear we
make the following two vectors.

\begin{align*}
	v_1 &=p_2-p_1 = \langle p_2.x-p_1.x,p_2.y-p_1.y\rangle\\
	v_2 &=p_3-p_1 = \langle p_3.x-p_1.x,p_3.y-p_1.y\rangle
\end{align*}
Lets denote $v_1 = \langle a,b\rangle$ and $v_2 = \langle c,d\rangle$
(see Figure \ref{fig:rightturn_a})
\subsubsection{Right turn}
\begin{figure}[H]
	\caption{Right turn}
    \centering
	\begin{subfigure}{.7\textwidth}
		\includegraphics[width=8cm]{figures/rightturn1.pdf}
		\caption{}
		\label{fig:rightturn_a}
	\end{subfigure}
    %
	\begin{subfigure}{.7\textwidth}
		\includegraphics[width=8cm]{figures/rightturn2.pdf}
		\caption{}
		\label{fig:rightturn_b}
	\end{subfigure}
\end{figure}
\nick{Find book ref to right turn}
We claim that we can calculate the turn by calculating the signed area of the
parallelogram spanned by the two vectors. The area of their parallelogram can
be calculated as follows: calculate the area of the big rectangle, and take the
two small triangles and the little square and subtract that area.
\begin{align}
	\text{area} &= (a+c)(d+b)-2A-2B-2C\nonumber\\
							&=ad+ab+cd+bc-cd-2ad-ab\nonumber\\
							&=bc-ad \nonumber\\
							&=(p_2.y-p_1.y)(p_3.x-p_1.x)-(p_2.x-p_1.x)(p_3.y-p_1.y)\label{form:rightturn}
\end{align}
Now we claim that the area between these two vectors is positive if the
three points make a right turn, and negative if they make a left turn. We show
that by an example (see figure \ref{rightturn3})

Given our formula (formula \ref{form:rightturn}) we get that the $q_1,q_3,q_2$ area is
\begin{align*}
	&(q_3.y-q_1.y)(q_2.x-q_1.x)-(q_3.x-q_1.x)(q_2.y-q_1.y)\\ 
	= &(2-0)(-1-0)-(0-0)(1-0)\\
	= & 2\cdot (-1)-0\cdot1\\
	= & -2-0\\
	= & -2
\end{align*}
And the area of $q_1,q_3,q_4$ is
\begin{align*}
	&(q_3.y-q_1.y)(q_4.x-q_1.x)-(q_3.x-q_1.x)(q_4.y-q_1.y)\\ 
	= &(2-0)(1-0)-(0-0)(1-0)\\
	= &(2\cdot 1 - 0\cdot 1\\
	= &2-0\\
	= &2
\end{align*}

\begin{figure}[H]
    \centering
	\includegraphics{figures/rightturn3.pdf}
	\caption{Right turn example}
    \label{rightturn3}
\end{figure}
So the function for calculating the right turn is
\begin{algorithm} 
	\caption{rightTurn($p_1,p_2,p_3$)}
	\begin{algorithmic}[1] 
		\State \Return $(p_2.x-p_1.x)(p_3.y-p_1.y)-(p_2.y-p_1.y)(p_3.x-p_1.x)$
	\end{algorithmic}
\end{algorithm}

This function will return a negative number if the three points make a left
turn, a positive number if it is a right turn and 0 if the three points are on
a line.

\subsubsection{Crossing of two line segments}
\begin{figure}[H]
	\caption{Crossing of two line segments}
	\minipage{0.32\textwidth}
		\includegraphics[width=2cm]{figures/crosses.pdf}
		\caption{}
		\label{fig:crosses_a}
	\endminipage\hfill
	\minipage{0.32\textwidth}
		\includegraphics[width=3cm]{figures/crosses1.pdf}
		\caption{}
		\label{fig:crosses_b}
	\endminipage\hfill
	\minipage{0.32\textwidth}
		\includegraphics[width=3cm]{figures/crosses2.pdf}
		\caption{}
		\label{fig:crosses_c}
		\endminipage\hfill
\end{figure}

\begin{Lemma}
	Given two line segments, $l_1$ and $l_2$, we want to know if they cross (see
	figure \ref{fig:crosses_a}). We start by taking the first line segment
	$l_1$ and check if the two points of $l_2$, $l_2.p$ and $l_2.q$ lie on
	separate sides of the line that is collinear to $l_1$, if this is the case
	we do a similar check the other way around, and if that is true the two line
	segment cross.
\end{Lemma}
\begin{proof}
Let $L_1$ and $L_2$ denote the lines collinear to $l_1$ and $l_2$ respectively.
	If both the end points of $l_2$ is on the same side of $L_1$, then the line
	segments can't cross $L_1$, and therefore $l_1$ obviously(see figure
	\ref{fig:crosses_b}). If they lie on opposite sites, $l_2$ crosses $L_1$ and
	we have to determine if $l_2$ crosses $L_1$ between $l_1.p$ and $l_1.q$. 

We know the line $l_2$ crosses $L_1$, the question is, is it between the two
	end points, we can quit easily determine this by looking at if the endpoints
	lie on opposite sites of $l_2$, like before(see figure \ref{fig:crosses_b}.
	If they do it must be the case that $l_1$ and $l_2$ crosses, if not it
	crosses $L_1$ another place.
\end{proof}

\subsubsection{Algorithm}
We can check weather the points lie on opposite sites
by multiplying the right turn results, since, if they lie on opposite sites,
they will have different sign, if the lie on the same site they have the same
sign so the result will be negative if they are on opposite sites and positive
if they are on the same side.
\nick{If its zero the hits an endpoint, write about that}
\begin{algorithm}[H]
	\caption{Crosses($l_1,l_2$)}
	\begin{algorithmic}[1] 
		\State foo = $rightTurn(l_1.p,l_1.q,l_2.p)\cdot
		rightTurn(l_1.p,l_1.q,l_2.q)$
		\State bar = $rightTurn(l_2.p,l_2.q,l_1.p)\cdot
		rightTurn(l_2.p,l_2.q,l_1.q)$
		\If{foo$<0$ and bar$<0$}
		\State \Return True
		\Else
		\State \Return False
		\EndIf
	\end{algorithmic}
\end{algorithm}

\section{Dijkstra}

Dijkstra's algorithm solves the single-source shortest path problem for a
weighted directed graph $G$. i.e. Given a graph $G=(V,E)$, where $V$ is the
vertices and $E$ is the directed weighted edges and a start vertex $s\in V$,
find the path where the sum of of the weights it the smallest possible.
Dijkstra original conceived the algorithm in his 1959 paper "A note on two
problems in connexion with graphs"\cite{dijkstra59}, the following description
is based on an "Introduction to Algorithms"\cite{IntroToAlg}, 24.3.

$v_\pi$ being either the predecessor or nill\nick{null nil???}. $v_d$ being the upper bound on
the weight of a shortest path from source $s$ to $v$. Running time $\Theta (V)$

\begin{algorithm} 
	\caption{Initialize-Single-Source(G,s)}
	\begin{algorithmic}[1] 
		\ForEach {vertex $v \in G.V$} 
			\State $v.d = \infty$
			\State $v.\pi =$ NIL 
		\EndFor 
		\State $s.d = 0$ 
	\end{algorithmic}
\end{algorithm}

Relaxing an edge $(u,v)$ consist of testing whether we can improve the shortest
path to $v$ found so far by going through $u$ and, if so, update $v.d$ and
$v.\pi$. We define $w$ as following for a path $p=\langle v_0,v_1,...,v_k
\rangle$

$$ w(p) = \sum_{i=1}^k w(v_{i-1},v_i) $$

\begin{algorithm} 
	\caption{Relax(u,v,w)} 
	\begin{algorithmic}[1] 
		\If {$v.d > u.d + w(u,v)$} 
			\State $v.d=u.d+w(u,v)$ 
			\State $v.\pi = u$ 
		\EndIf 
		\State $s.d = 0$
	\end{algorithmic} 
\end{algorithm}

$Q$ acts as a min-priority queue to contain all the vertices in $V$. Naive
implementation of Dijkstra yields $O((V+E)lgV)$ which is $O(E \cdot lgV)$ if
all vertices are reachable from the source. And can be $O(V^2)$ if
$E=o(V^2/lgV)$. Extract min runs in $O(lgV)$ 

\begin{algorithm}[H]
	\caption{Dijkstra(G,w,s)} 
	\begin{algorithmic}[1] 
		\State Initialize-Single-Source(G,s) 
		\State $S = \emptyset$ 
		\State $Q = G.V$ 
		\While {$Q \not= \emptyset$} 
			\State $u = $Extract-Min(Q) 
			\State $S = S \cup \{u\}$
			\ForEach {vertex $v \in G.Adj[u]$} 
				\State Relax(u,v,w) 
			\EndFor 
		\EndWhile
	\end{algorithmic} 
\end{algorithm}

\section{Experiment}
In this section we will go through the experiments we did with the algorithm,
both for running time and test of correctness.
\subsection{Computer specification}
The test were run on a computer with the following specification
\begin{figure}[H]
\begin{tabular}{| c | l |}
	\hline
	Model & Lenovo ThinkPad, x230 \\
	\hline
	Operating system & Arch Linux \\
	\hline
	CPU & Intel(R) Core(TM) i7-3520M CPU @ 2.90GHz\\
	\hline
	Memory & 8 GB \\
	\hline
\end{tabular}
\end{figure}
\subsection{Correctness of algorithm}
We tested the correctness of our algorithm by creating a lots of examples and
made our program able to output a svg image of the polygons and route so we
were able to confirm the algorithm made the correct visibility graph. (See
figure \ref{fig:correctness_1} and \ref{fig:correctness_2}
\begin{figure}[H]
	\caption{Examples of figures for correctness}
	\begin{subfigure}{.5\textwidth}
		\includegraphics[width=6cm]{figures/correctness1.pdf}
		\caption{}
		\label{fig:correctness_1}
	\end{subfigure}
	\begin{subfigure}{.5\textwidth}
		\includegraphics[width=6cm]{figures/correctness2.pdf}
		\caption{}
		\label{fig:correctness_2}
	\end{subfigure}
\end{figure}

\subsection{Running time of algorithm}
To test the running time of our algorithm we autogenerated a map consisting of
x times x squares and put $s$ and $t$ in oppersite conners (see figure
\ref{fig:test})
\begin{figure}[H]
	\caption{Examples of figures for correctness}
		\includegraphics[width=6cm]{figures/testexample.pdf}
		\label{fig:test}
\end{figure}

We ran the algorithm where the number of violations was a constant $5$ and the
number of squares was $n=t^2$ for $t=1,\dots,41$ and got the following graph
\input{graph/graph1.tex}

Then we tried figuring out where the time was spent so we tried measuring the
crossing function, the construction of visibility graph and the dijkstra
seperately and got the following
\input{graph/graph2.tex}

The algorithm is totally dominatet by the crossing calculating which makes
sense as the $O(n^3)$ is the most dominint, we tried dividing the first graph
with $O(n^3)$ and got the following
\input{graph/graph3.tex}

Lastly we tried to make a test where $n=25^2$ and $k=1,\dots,25$ and getting
the almost linear graph
\input{graph/graph4.tex}

In conclussion we have implemented a naive $O()$ algorithm and made tests both
confirming the correctness and the running time of the algorithm.
